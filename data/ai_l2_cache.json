{
  "AIItem": {
    "l2": "{\"purpose\": \"Класс AIItem в прототипе RAG-системы. (Doc: N/A...). Snippet: class AIItem:\\n\\n    def __init__(self, id: str, type: str, contract: Dict[str, An...\", \"uses\": [\"Called by AIItem.__init__\", \"Called by AIItem.generate_l2\"], \"returns\": \"instance\", \"edge_cases\": \"Conditional logic\"}",
    "type": "class",
    "file_path": "C:\\ERV\\projects-ex\\kosmos-backend\\rag_engine.py",
    "source": "LLM",
    "timestamp": 1764153452.3911078
  },
  "AIItem.__init__": {
    "l2": "{\"purpose\": \"Функция __init__ в прототипе RAG. (Doc: N/A...) Args: self, id, type, contract. Snippet: def __init__(self, id: str, type: str, contract: Dict[str, Any]):\\n    self.id = ...\", \"uses\": [\"Called by AIItem\"], \"returns\": \"result\", \"edge_cases\": \"N/A\"}",
    "type": "function",
    "file_path": "C:\\ERV\\projects-ex\\kosmos-backend\\rag_engine.py",
    "source": "LLM",
    "timestamp": 1764153452.3911078
  },
  "AIItem.generate_l2": {
    "l2": "{\"purpose\": \"Функция generate_l2 в прототипе RAG. (Doc: N/A...) Args: self, generator. Snippet: def generate_l2(self, generator: Optional['L2Generator']=None):\\n    if self.l2 i...\", \"uses\": [\"Called by AIItem\", \"Called by AIItem.generate_l2\"], \"returns\": \"result\", \"edge_cases\": \"Conditional logic\"}",
    "type": "function",
    "file_path": "C:\\ERV\\projects-ex\\kosmos-backend\\rag_engine.py",
    "source": "LLM",
    "timestamp": 1764153452.3911078
  },
  "get_l0_snippet": {
    "l2": "{\"purpose\": \"Функция get_l0_snippet в прототипе RAG. (Doc: Получает L0 код из кэша по id....) Args: item_id, max_len. Snippet: def get_l0_snippet(item_id: str, max_len: int=None) -> str:\\n    \\\"\\\"\\\"Получает L0 к...\", \"uses\": [\"Called by polish_l1_with_llm\"], \"returns\": \"result\", \"edge_cases\": \"Conditional logic; Error handling\"}",
    "type": "function",
    "file_path": "C:\\ERV\\projects-ex\\kosmos-backend\\rag_engine.py",
    "source": "LLM",
    "timestamp": 1764153452.3911078
  },
  "L2Generator": {
    "l2": "{\"purpose\": \"Класс L2Generator в прототипе RAG-системы. (Doc: Генератор L2 c LLM и fallback....). Snippet: class L2Generator:\\n    \\\"\\\"\\\"Генератор L2 c LLM и fallback.\\\"\\\"\\\"\\n\\n    def __init__(se...\", \"uses\": [\"Called by L2Generator.__init__\", \"Called by L2Generator._fallback_l2\", \"Called by L2Generator.generate_l2\"], \"returns\": \"instance\", \"edge_cases\": \"Conditional logic; Error handling; Iteration\"}",
    "type": "class",
    "file_path": "C:\\ERV\\projects-ex\\kosmos-backend\\rag_engine.py",
    "source": "LLM",
    "timestamp": 1764153452.3911078
  },
  "L2Generator.__init__": {
    "l2": "{\"purpose\": \"Инициализирует объект L2Generator, сохраняя конфигурацию доступа к LLM и режимов работы.\", \"uses\": [\"self.api_url\", \"self.model\", \"self.max_retries\", \"self.dry_run\", \"self.llm_raw\"], \"returns\": \"Никакого значения (конструктор).\", \"edge_cases\": \"Отсутствие переданных аргументов приводит к использованию значений по умолчанию; неверные типы могут вызвать ошибки позже.\"}",
    "type": "function",
    "file_path": "C:\\ERV\\projects-ex\\kosmos-backend\\rag_engine.py",
    "source": "LLM",
    "timestamp": 1764153452.3911078
  },
  "L2Generator.generate_l2": {
    "l2": "{\"purpose\": \"Генерирует описание L2 для одного AIItem, используя LLM или fallback‑метод.\", \"uses\": [\"self.dry_run\", \"self._fallback_l2\", \"self._build_prompt\", \"LLM API (через self.api_url)\", \"json.loads\"], \"returns\": \"Словарь с полями purpose, uses, returns, edge_cases для переданного item.\", \"edge_cases\": \"При dry_run сразу вызывается fallback; если LLM не отвечает или возвращает неверный JSON, может потребоваться обработка исключений.\"}",
    "type": "function",
    "file_path": "C:\\ERV\\projects-ex\\kosmos-backend\\rag_engine.py",
    "source": "LLM",
    "timestamp": 1764153452.3911078
  },
  "L2Generator.generate_l2_batch": {
    "l2": "{\"purpose\": \"Генерирует L2‑описания для списка AIItem‑ов пакетами, используя LLM или fallback.\", \"uses\": [\"self.dry_run\", \"self._fallback_l2\", \"self.generate_l2\", \"batch_size\", \"list iteration\"], \"returns\": \"Список AIItem, у которых поле l2 заполнено (или оставлено None при ошибке).\", \"edge_cases\": \"Если dry_run=True, каждый элемент получает fallback‑описание; при неполном заполнении l2 у некоторых items может потребоваться повторный вызов.\"}",
    "type": "function",
    "file_path": "C:\\ERV\\projects-ex\\kosmos-backend\\rag_engine.py",
    "source": "LLM",
    "timestamp": 1764153452.3911078
  },
  "L2Generator._build_prompt": {
    "l2": "{\"purpose\": \"Формирует текстовый запрос (prompt) для LLM на основе контракта и связей AIItem.\", \"uses\": [\"item.contract\", \"item.l1_edges\", \"get_l...\", \"string formatting\"], \"returns\": \"Строка‑prompt, содержащая аргументы, docstring и список использований (calls).\", \"edge_cases\": \"Если в контракте нет args или docstring, подставляются заглушки 'N/A' и 'No docstring'; при отсутствии l1_edges берутся uses из контракта.\"}",
    "type": "function",
    "file_path": "C:\\ERV\\projects-ex\\kosmos-backend\\rag_engine.py",
    "source": "LLM",
    "timestamp": 1764153452.3911078
  },
  "L2Generator._fallback_l2": {
    "l2": "{\"purpose\": \"Функция _fallback_l2 в прототипе RAG. (Doc: Fallback: auto + docstring + snippet + edges для п...) Args: self, item. Snippet: def _fallback_l2(self, item: AIItem) -> Dict[str, Any]:\\n    \\\"\\\"\\\"Fallback: auto + ...\", \"uses\": [\"Called by L2Generator.generate_l2_batch\", \"Called by L2Generator\", \"Called by L2Generator.generate_l2\"], \"returns\": \"result\", \"edge_cases\": \"Conditional logic; Error handling; Iteration\"}",
    "type": "function",
    "file_path": "C:\\ERV\\projects-ex\\kosmos-backend\\rag_engine.py",
    "source": "LLM",
    "timestamp": 1764153452.3911078
  },
  "EmbedRetriever": {
    "l2": "{\"purpose\": \"Класс EmbedRetriever в прототипе RAG-системы. (Doc: N/A...). Snippet: class EmbedRetriever:\\n\\n    def __init__(self, dim: int=384, model_name: str='int...\", \"uses\": [\"Called by EmbedRetriever._generate_if_needed\", \"Called by EmbedRetriever.add_items\", \"Called by EmbedRetriever.encode_query\"], \"returns\": \"instance\", \"edge_cases\": \"Conditional logic; Error handling; Iteration\"}",
    "type": "class",
    "file_path": "C:\\ERV\\projects-ex\\kosmos-backend\\rag_engine.py",
    "source": "LLM",
    "timestamp": 1764153452.3911078
  },
  "EmbedRetriever.__init__": {
    "l2": "{\"purpose\": \"Функция __init__ в прототипе RAG. (Doc: N/A...) Args: self, dim, model_name, pickle_path. Snippet: def __init__(self, dim: int=384, model_name: str='intfloat/e5-small-v2', pickle_...\", \"uses\": [\"Called by EmbedRetriever\", \"Called by EmbedRetriever._try_load\"], \"returns\": \"result\", \"edge_cases\": \"Error handling\"}",
    "type": "function",
    "file_path": "C:\\ERV\\projects-ex\\kosmos-backend\\rag_engine.py",
    "source": "LLM",
    "timestamp": 1764153452.3916125
  },
  "EmbedRetriever.add_items": {
    "l2": "{\"purpose\": \"Функция add_items в прототипе RAG. (Doc: N/A...) Args: self, ai_items, generator, l2_batch_size. Snippet: def add_items(self, ai_items: Dict[str, AIItem], generator: Optional[L2Generator...\", \"uses\": [\"Called by EmbedRetriever._encode\", \"Called by EmbedRetriever._save_pickle\", \"Called by EmbedRetriever._generate_if_needed\"], \"returns\": \"result\", \"edge_cases\": \"Conditional logic; Iteration\"}",
    "type": "function",
    "file_path": "C:\\ERV\\projects-ex\\kosmos-backend\\rag_engine.py",
    "source": "LLM",
    "timestamp": 1764153452.3916125
  },
  "EmbedRetriever._try_load": {
    "l2": "{\"purpose\": \"Функция _try_load в прототипе RAG. (Doc: N/A...) Args: self. Snippet: def _try_load(self):\\n    try:\\n        with open(self.pickle_path, 'rb') as f:\\n  ...\", \"uses\": [\"Called by EmbedRetriever\", \"Called by EmbedRetriever.__init__\"], \"returns\": \"result\", \"edge_cases\": \"Error handling; Iteration\"}",
    "type": "function",
    "file_path": "C:\\ERV\\projects-ex\\kosmos-backend\\rag_engine.py",
    "source": "LLM",
    "timestamp": 1764153452.3916125
  },
  "EmbedRetriever._generate_if_needed": {
    "l2": "{\"purpose\": \"Генерирует эмбеддинги для всех текстов, если они ещё не загружены\", \"uses\": [\"self.loaded\", \"self.texts\", \"self._encode\", \"self.embeddings_dict\", \"self.ids_dict\"], \"returns\": \"None (выполняет заполнение self.embeddings_dict)\", \"edge_cases\": \"Возврат без действий, если уже загружено (self.loaded=True) или texts пустой; при ошибке в _encode может бросить исключение\"}",
    "type": "function",
    "file_path": "C:\\ERV\\projects-ex\\kosmos-backend\\rag_engine.py",
    "source": "LLM",
    "timestamp": 1764153452.3916125
  },
  "EmbedRetriever._encode": {
    "l2": "{\"purpose\": \"Преобразует список строк в массив эмбеддингов с помощью SentenceTransformer\", \"uses\": [\"REAL_MODEL\", \"self.model_name\", \"self.model\", \"SentenceTransformer\", \"np.ndarray\"], \"returns\": \"np.ndarray с эмбеддингами для переданных текстов\", \"edge_cases\": \"Если REAL_MODEL=False или модель не инициализирована – возвращает None; при первом вызове загружает модель; добавляет префиксы 'passage: ' к каждому тексту\"}",
    "type": "function",
    "file_path": "C:\\ERV\\projects-ex\\kosmos-backend\\rag_engine.py",
    "source": "LLM",
    "timestamp": 1764153452.3916125
  },
  "EmbedRetriever._save_pickle": {
    "l2": "{\"purpose\": \"Сохраняет текущие эмбеддинги, тексты и их идентификаторы в файл pickle\", \"uses\": [\"self.embeddings_dict\", \"self.texts\", \"self.pickle_path\", \"pickle.dump\", \"np.stack\"], \"returns\": \"None (файл записывается на диск)\", \"edge_cases\": \"Если embeddings_dict пустой – np.stack вызовет ошибку; путь pickle_path может быть недоступен для записи\"}",
    "type": "function",
    "file_path": "C:\\ERV\\projects-ex\\kosmos-backend\\rag_engine.py",
    "source": "LLM",
    "timestamp": 1764153452.3916125
  },
  "EmbedRetriever.encode_query": {
    "l2": "{\"purpose\": \"Получает эмбеддинг для поискового запроса\", \"uses\": [\"REAL_MODEL\", \"self.model\", \"self.dim\", \"np.random\"], \"returns\": \"np.ndarray размером self.dim с эмбеддингом запроса\", \"edge_cases\": \"Если модель недоступна – генерирует случайный вектор с фиксированным seed (детерминированный); может вернуть вектор неправильного типа, если self.dim не задан\"}",
    "type": "function",
    "file_path": "C:\\ERV\\projects-ex\\kosmos-backend\\rag_engine.py",
    "source": "LLM",
    "timestamp": 1764153452.3916125
  },
  "EmbedRetriever.get_similarities": {
    "l2": "{\"purpose\": \"Вычисляет косинусные сходства между запросом и выбранными элементами\", \"uses\": [\"sklearn.metrics.pairwise.cosine_similarity\", \"self.embeddings_dict\", \"np.zeros\"], \"returns\": \"np.ndarray с коэффициентами сходства для каждого item_id из входного списка\", \"edge_cases\": \"Если ни один из item_ids не найден в embeddings_dict – возвращает нулевой массив той же длины; при разных размеров векторов может бросить ошибку\"}",
    "type": "function",
    "file_path": "C:\\ERV\\projects-ex\\kosmos-backend\\rag_engine.py",
    "source": "LLM",
    "timestamp": 1764153452.3916125
  },
  "build_graph": {
    "l2": "{\"purpose\": \"Создаёт направленный граф зависимостей между AI‑элементами\", \"uses\": [\"networkx\", \"AIItem.type\", \"AIItem.contract\", \"calls_dict\"], \"returns\": \"nx.DiGraph с узлами‑элементами и ребрами‑вызовами\", \"edge_cases\": \"Если в calls_dict присутствуют ссылки на несуществующие item_id – они игнорируются; при save_cache=True может потребоваться дополнительная логика кэширования\"}",
    "type": "function",
    "file_path": "C:\\ERV\\projects-ex\\kosmos-backend\\rag_engine.py",
    "source": "LLM",
    "timestamp": 1764153452.3916125
  },
  "retrieve_hybrid": {
    "l2": "{\"purpose\": \"Выполняет гибридный поиск: сначала векторный поиск, затем учитывает графовые связи\", \"uses\": [\"EmbedRetriever\", \"networkx\", \"ai_items\", \"build_graph\"], \"returns\": \"List[AIItem] – отобранные элементы в порядке релевантности\", \"edge_cases\": \"Если запрос слишком короткий, keyword‑матчинг может вернуть пустой список; при отсутствии соседних узлов в графе возвращаются только векторные результаты\"}",
    "type": "function",
    "file_path": "C:\\ERV\\projects-ex\\kosmos-backend\\rag_engine.py",
    "source": "LLM",
    "timestamp": 1764153452.3916125
  },
  "parse_self_to_ai_items": {
    "l2": "{\"purpose\": \"Парсит исходный файл текущего модуля в набор AIItem и словарь вызовов\", \"uses\": [\"ast\", \"ImprovedCodeParser\", \"auto_l1\", \"llm_l1\", \"api_url\"], \"returns\": \"tuple[Dict[str, AIItem], Dict[str, List[str]]] – словарь элементов и их вызовов\", \"edge_cases\": \"Если файл содержит синтаксические ошибки – ast.parse бросит исключение; при отключённом auto_l1/llm_l1 может быть пустой набор элементов\"}",
    "type": "function",
    "file_path": "C:\\ERV\\projects-ex\\kosmos-backend\\rag_engine.py",
    "source": "LLM",
    "timestamp": 1764153452.3916125
  },
  "ImprovedCodeParser": {
    "l2": "{\"purpose\": \"Класс‑посетитель AST, собирающий информацию о классах, функциях и их вызовах/присваиваниях\", \"uses\": [\"ast.NodeVisitor\", \"self.items\", \"self.calls_dict\", \"self.assigns_dict\", \"self.imports_dict\"], \"returns\": \"Экземпляр, готовый к вызову visit() для анализа кода\", \"edge_cases\": \"Не обрабатывает динамические импорты и вызовы через eval/exec; встроенные имена задаются в self.built_ins\"}",
    "type": "class",
    "file_path": "C:\\ERV\\projects-ex\\kosmos-backend\\rag_engine.py",
    "source": "LLM",
    "timestamp": 1764153452.3916125
  },
  "ImprovedCodeParser.__init__": {
    "l2": "{\"purpose\": \"Инициализирует структуры для хранения найденных элементов и зависимостей\", \"uses\": [], \"returns\": \"None (инициализация полей экземпляра)\", \"edge_cases\": \"Список built_ins фиксирован; при необходимости расширения его нужно менять вручную\"}",
    "type": "function",
    "file_path": "C:\\ERV\\projects-ex\\kosmos-backend\\rag_engine.py",
    "source": "LLM",
    "timestamp": 1764153452.3916125
  },
  "ImprovedCodeParser.visit_ClassDef": {
    "l2": "{\"purpose\": \"Функция visit_ClassDef в прототипе RAG. (Doc: N/A...) Args: self, node. Snippet: def visit_ClassDef(self, node):\\n    self.current_class = node.name\\n    self.call...\", \"uses\": [\"Called by ImprovedCodeParser\"], \"returns\": \"result\", \"edge_cases\": \"Conditional logic; Iteration\"}",
    "type": "function",
    "file_path": "C:\\ERV\\projects-ex\\kosmos-backend\\rag_engine.py",
    "source": "LLM",
    "timestamp": 1764153452.3916125
  },
  "ImprovedCodeParser.visit_FunctionDef": {
    "l2": "{\"purpose\": \"Функция visit_FunctionDef в прототипе RAG. (Doc: N/A...) Args: self, node. Snippet: def visit_FunctionDef(self, node):\\n    self.current_func = node.name\\n    snippet...\", \"uses\": [\"Called by ImprovedCodeParser\"], \"returns\": \"result\", \"edge_cases\": \"Conditional logic; Iteration\"}",
    "type": "function",
    "file_path": "C:\\ERV\\projects-ex\\kosmos-backend\\rag_engine.py",
    "source": "LLM",
    "timestamp": 1764153452.3916125
  },
  "ImprovedCodeParser.visit_Call": {
    "l2": "{\"purpose\": \"Функция visit_Call в прототипе RAG. (Doc: N/A...) Args: self, node. Snippet: def visit_Call(self, node):\\n    called = None\\n    if isinstance(node.func, ast.A...\", \"uses\": [\"Called by ImprovedCodeParser\"], \"returns\": \"result\", \"edge_cases\": \"Conditional logic\"}",
    "type": "function",
    "file_path": "C:\\ERV\\projects-ex\\kosmos-backend\\rag_engine.py",
    "source": "LLM",
    "timestamp": 1764153452.3916125
  },
  "ImprovedCodeParser.visit_Assign": {
    "l2": "{\"purpose\": \"Функция visit_Assign в прототипе RAG. (Doc: N/A...) Args: self, node. Snippet: def visit_Assign(self, node):\\n    if self.current_func:\\n        caller_id = f'{s...\", \"uses\": [\"Called by ImprovedCodeParser\"], \"returns\": \"result\", \"edge_cases\": \"Conditional logic\"}",
    "type": "function",
    "file_path": "C:\\ERV\\projects-ex\\kosmos-backend\\rag_engine.py",
    "source": "LLM",
    "timestamp": 1764153452.3916125
  },
  "ImprovedCodeParser.visit_Import": {
    "l2": "{\"purpose\": \"Функция visit_Import в прототипе RAG. (Doc: N/A...) Args: self, node. Snippet: def visit_Import(self, node):\\n    if self.current_func or self.current_class:\\n  ...\", \"uses\": [\"Called by ImprovedCodeParser\"], \"returns\": \"result\", \"edge_cases\": \"Conditional logic; Iteration\"}",
    "type": "function",
    "file_path": "C:\\ERV\\projects-ex\\kosmos-backend\\rag_engine.py",
    "source": "LLM",
    "timestamp": 1764153452.3916125
  },
  "ImprovedCodeParser.visit_ImportFrom": {
    "l2": "{\"purpose\": \"Функция visit_ImportFrom в прототипе RAG. (Doc: N/A...) Args: self, node. Snippet: def visit_ImportFrom(self, node):\\n    if self.current_func or self.current_class...\", \"uses\": [\"Called by ImprovedCodeParser\"], \"returns\": \"result\", \"edge_cases\": \"Conditional logic; Iteration\"}",
    "type": "function",
    "file_path": "C:\\ERV\\projects-ex\\kosmos-backend\\rag_engine.py",
    "source": "LLM",
    "timestamp": 1764153452.3916125
  },
  "init_engine": {
    "l2": "{\"purpose\": \"Инициализирует RAG‑движок: задаёт глобальные объекты, настраивает кэш и параметры соединения с LLM\", \"uses\": [\"global ai_items\", \"global G\", \"global retriever\", \"global l2_generator\", \"print\", \"параметры функции (use_llm_l1, load_cache, save_cache, api_url, model, llm_raw)\"], \"returns\": \"None (функция инициализирует глобальное состояние и ничего не возвращает)\", \"edge_cases\": \"Если load_cache=False – кэш не загружается; если save_cache=False – изменения не сохраняются; неверный api_url или недоступный сервер могут вызвать исключения; параметр model должен соответствовать поддерживаемым моделям; при use_llm_l1=True переключается на LLM первого уровня\"}",
    "type": "function",
    "file_path": "C:\\ERV\\projects-ex\\kosmos-backend\\rag_engine.py",
    "source": "LLM",
    "timestamp": 1764153452.3916125
  }
}