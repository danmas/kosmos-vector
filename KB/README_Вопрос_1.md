# Анализ проекта KOSMOS-VECTOR (AIAN Vector)

**Дата создания:** 2025-01-15  
**Источник:** Анализ README файлов в корне проекта и папке ./KB

---

## 1. Название проекта

- **Рабочее название:** `kosmos-vector`
- **Официальное/Package:** `AIAN Vector` / `aian-vector-monorepo`
- **Альтернативное:** `KOSMOS-VECTOR`

---

## 2. Что делает / какую проблему решает

**Полноценный RAG-сервер для семантического поиска и анализа кодовой базы.** Автоматически разбивает исходный код (JS/TS, SQL, Markdown) на логические блоки (чанки), векторизует их и хранит в PostgreSQL. Позволяет AI-агентам и разработчикам задавать вопросы к кодовой базе на естественном языке и получать релевантные фрагменты кода с контекстом.

**Основные сценарии использования:**
- Поиск релевантного кода по семантическому запросу
- Автоматическая каталогизация SQL-объектов и JS-модулей
- Построение базы знаний для LLM-ассистентов разработчика
- Анализ зависимостей между компонентами кодовой базы

---

## 3. Целевая аудитория / пользователи / заказчики

- **Разработчики** — получение контекста и понимания legacy/большого кода
- **AI-агенты / LLM-ассистенты** — инфраструктурный слой для подачи контекста кода в промпты
- **DevOps/команды** — каталогизация SQL-объектов, JS-модулей, построение внутренней базы знаний
- **Внутренние проекты** — судя по путям в конфигах (`CARL`, `CARLINK`), возможно есть внутренний заказчик/проект

---

## 4. Главная ценность / уникальность / отличие от аналогов

| Ценность | Детали |
|----------|--------|
| **Специализированные парсеры** | Умное разбиение по структуре языка: функции, классы, таблицы, процедуры — а не просто по размеру |
| **Многоуровневая система чанков** | L0 (исходник) → L1 (связи) → L2 (логика) — иерархия абстракции |
| **AI Items** | Логические сущности с автоматической привязкой к чанкам — структурированная навигация |
| **pgvector в PostgreSQL** | Всё хранится в реляционной БД без отдельных vector DB |
| **UI для управления** | Веб-интерфейс для вопросов, векторизации, просмотра чанков |
| **Knowledge Base Configuration** | Гибкая система конфигурации для выбора файлов проекта (includeMask, fileSelection) |

---

## 5. Текущая стадия

**MVP → Бета**

**Что работает:**
- ✅ Базовый функционал: векторизация, поиск, UI, REST API
- ✅ Тесты (end-to-end, интеграционные)
- ✅ Подробная документация в `./KB`
- ✅ Автоматическое создание AI Items при векторизации L0 чанков
- ✅ Специализированные парсеры для JS/SQL/MD

**Что частично работает:**
- ⚠️ Ограниченный набор поддерживаемых языков (JS, SQL, MD, частично Java)
- ⚠️ L1/L2 генерируются **вручную** (не автоматически при векторизации)
- ⚠️ Связи между AI Items — текстовые, нет реального графа зависимостей
- ⚠️ Нет аутентификации (ориентация на локальную разработку)

---

## 6. Технологический стек / ключевые компоненты

| Компонент | Технология |
|-----------|------------|
| **Runtime** | Bun ≥ 1.0.0 |
| **Сервер** | Express.js |
| **Язык** | JavaScript (pure, без TS в runtime) |
| **БД** | PostgreSQL 14+ с расширением `pgvector` |
| **Эмбеддинги** | SimpleEmbeddings (локальные, детерминированные) / OpenAI `text-embedding-ada-002` |
| **LLM для ответов** | Внешний AI-сервер через `REQ_SERVER_URL` (например Gemini) |
| **UI** | Статическая SPA (HTML/CSS/JS без сборщика) |
| **Архитектура** | Monorepo с workspaces, разделение `packages/core` и `server-v2` |
| **API** | REST API с OpenAPI-контрактом (`docs/api-contract.yaml`) |

**Ключевые компоненты:**
- `packages/core` — ядро бизнес-логики (DbService, PostgresVectorStore, textSplitters, vectorOperations)
- `server-v2` — тонкий сервер на Express.js
- `public/` — статический UI
- `KB/` — база знаний (документация)

---

## 7. Главная цель на ближайшие 3–12 месяцев

**Не указано явно в документации**, но исходя из анализа кода и документации, вероятные цели:

- **Расширение поддержки языков** — сейчас только JS/SQL/MD, частично Java
- **Автоматизация генерации L1/L2** — сейчас требует ручных вызовов API
- **Упрощение архитектуры** — документация сама признаёт "переусложнённость"
- **Построение реального графа зависимостей** — сейчас связи только текстовые
- **Стабилизация и production-ready** — добавление аутентификации, улучшение масштабируемости

---

## 8. Самые большие текущие риски / блокеры / сомнения

| Риск | Описание | Критичность |
|------|----------|-------------|
| **Переусложнённая архитектура** | Документация сама признаёт: "сложность архитектуры превышает практическую пользу" | Высокая |
| **Эвристический парсинг** | Разбор SQL/JS не 100% точный, regex-based, возможны ошибки | Средняя |
| **Масштабируемость** | При больших кодовых базах слишком много AI Items, нет автодедупликации | Высокая |
| **Orphaned AI Items** | Остаются после удаления чанков, нужна ручная очистка | Средняя |
| **L1/L2 — ручной процесс** | Каждый вызов = запрос к платному AI API, нет автоматизации | Средняя |
| **Связи — только текстовые** | Нельзя построить граф зависимостей SQL-запросом | Средняя |
| **Тесты используют mock AI** | Не проверяется реальное качество генерации | Низкая |
| **Нет версионирования** | Изменения в AI Items не отслеживаются | Низкая |
| **Стоимость генерации L1/L2** | Для большого проекта (1000+ функций) = 2000 запросов к AI | Средняя |

---

## 9. Всё остальное, что критически важно знать на старте

### 9.1. База знаний в `./KB`

**ВАЖНО:** База знаний находится в папке `./KB`. При формировании ответов в первую очередь обращайся туда. README в корне проекта прямо указывает: "ВАЖНО!!! База Знаний(набор README... файлов) находится в папке ./KB . При формировании ответов в первую очередь обращайся туда."

**Ключевые файлы:**
- `README_TECH.md` — техническая документация, архитектура
- `README_REST.md` — REST API документация
- `README_UI.md` — UI руководство
- `README_AI_ITEM_COMPLETE.md` — полное руководство по системе AI Items
- `README_EMBEDDING.md` — как происходит embedding
- `README_DB-VECTOR.md` — работа с базой данных и векторами

### 9.2. Контексты (`context_code`)

**Ключевой механизм группировки.** Позволяет хранить несколько "проектов" в одной БД:
- `DEFAULT` — контекст по умолчанию
- `CARL`, `TEST`, `KOSMOS-VECTOR` — примеры из конфигов

Используется для фильтрации при поиске, векторизации, управлении AI Items.

### 9.3. Два режима эмбеддингов

**1. SimpleEmbeddings (`USE_OPENAI=false`):**
- Локальная реализация
- Детерминированные векторы размерностью 1536
- Для разработки и тестирования
- Не использует внешние серверы

**2. OpenAIEmbeddings (`USE_OPENAI=true`):**
- Использует OpenAI API
- Модель: `text-embedding-ada-002`
- Требует `OPENAI_API_KEY`
- Для production

### 9.4. Внешний AI-сервер обязателен

**Для RAG-ответов (`/ask`):**
- Переменная `REQ_SERVER_URL` (например `http://localhost:3002`)
- `DEFAULT_MODEL_NAME` (например `google/gemini-2.0-flash-exp:free`)
- Без него `/ask` не сможет генерировать ответы

### 9.5. KB-конфиги

**Управление выбором файлов проекта:**
- Хранятся в `./kb-configs/{context-code}.json`
- Содержат: `rootPath`, `includeMask`, `ignorePatterns`, `fileSelection`, `metadata`
- Приоритет: `fileSelection` > `includeMask`

### 9.6. Схема БД создаётся автоматически

**При `DbService.initializeSchema()`:**
- Таблицы: `files`, `chunk_vector`, `ai_item`
- Индексы для векторного поиска
- Расширение `pgvector` нужно установить вручную один раз: `CREATE EXTENSION IF NOT EXISTS vector;`

### 9.7. OpenAPI-контракт

**Файл:** `docs/api-contract.yaml`  
Полезно для интеграций и генерации клиентов.

### 9.8. Многоуровневая система чанков

**L0 (0-исходник):**
- Автоматически создаётся при векторизации
- Содержит исходный код объекта
- Автоматически связывается с AI Item при наличии `full_name`

**L1 (1-связи):**
- Описание связей между объектами
- Генерируется **вручную** через API `/api/ai/ai-item/:id/generate-chunk`
- Использует промпты из `.env` или пользовательские

**L2 (2-логика):**
- Описание бизнес-логики
- Генерируется **вручную** через API
- Может содержать граф потока управления (Logic Graph)

### 9.9. Специализированные парсеры

**JavaScript/TypeScript:**
- `splitJsByObjects()` — извлекает функции, классы, методы, интерфейсы
- Опции: `includeComments`, `parseImports`

**SQL:**
- `splitSqlByObjects()` — извлекает таблицы, функции, процедуры, views, triggers, indexes
- Определяет имена со схемой (например: `public.users`)

**Markdown:**
- `splitMarkdownBySections()` — разбивает по заголовкам
- Сохраняет иерархию заголовков

### 9.10. Система комментариев для AI Items

**Автоматическое сохранение:**
- При сохранении L0 чанков, если в `chunk_content.comment` присутствует значение
- API: `GET/POST/PUT/DELETE /api/items/{id}/comment?context-code=...`

### 9.11. Pipeline обработки

**Два режима работы:**
1. **Точный выбор:** `fileSelection.length > 0` → используются только файлы из списка
2. **Glob-маски:** `fileSelection` пуст → сканирование по `includeMask` и `ignorePatterns`

**Шаги:**
- `step1Runner.js` — сканирование и выбор файлов
- `step2Runner.js` — векторизация выбранных файлов
- История сохраняется в `data/pipeline_history.json`

### 9.12. Очистка базы данных

**Эндпоинты (требуют `confirm: true`):**
- `POST /clear-database` — логическая очистка (DELETE)
- `POST /truncate-database` — жёсткая очистка (TRUNCATE)
- `POST /cleanup-orphaned-ai-items` — очистка осиротевших AI Items

---

## Итоговая таблица: Статус функциональности

| Функциональность | Статус | Автоматически? | Качество |
|------------------|--------|----------------|----------|
| Разбиение JS на функции/классы | ✅ Да | ✅ Да | Высокое |
| Разбиение SQL на таблицы/функции | ✅ Да | ✅ Да | Высокое |
| Разбиение MD на секции | ✅ Да | ✅ Да | Высокое |
| Создание AI Items | ✅ Да | ✅ Да | Отлично |
| Сохранение L0 чанков | ✅ Да | ✅ Да | Отлично |
| Генерация L1 чанков | ⚠️ Частично | ❌ Нет | Зависит от AI |
| Генерация L2 чанков | ⚠️ Частично | ❌ Нет | Зависит от AI |
| API для генерации L1/L2 | ✅ Да | N/A | Отлично |
| Автоматический выбор промптов | ✅ Да | ✅ Да | Хорошее |
| Пользовательские промпты | ✅ Да | N/A | Отлично |
| Связь чанков с AI Items | ✅ Да | ✅ Да | Отлично |
| End-to-end тесты | ✅ Да | N/A | Хорошее |
| Тесты для SQL | ❌ Нет | N/A | - |
| Реальные вызовы AI в тестах | ❌ Нет | N/A | - |

---

## Заключение

**KOSMOS-VECTOR (AIAN Vector)** — это амбициозный проект для создания структурированной системы знаний с автоматической категоризацией объектов кода. 

**Сильные стороны:**
- Работающая система векторизации с специализированными парсерами
- Многоуровневая система чанков (L0/L1/L2)
- Автоматическое создание AI Items
- Полноценный UI и REST API
- Подробная документация

**Слабые стороны:**
- Переусложнённая архитектура
- L1/L2 требуют ручной генерации
- Связи между объектами только текстовые
- Ограниченная масштабируемость
- Эвристический парсинг (не 100% точный)

**Рекомендации:**
- Упростить архитектуру
- Автоматизировать генерацию L1/L2 для ключевых объектов
- Добавить реальный граф зависимостей
- Улучшить масштабируемость и дедупликацию

---

**Источники:**
- `README.md` (корень проекта)
- `README_about.md`
- `KB/README_TECH.md`
- `KB/README_REST.md`
- `KB/README_UI.md`
- `KB/README_AI_ITEM_COMPLETE.md`
- `KB/README_EMBEDDING.md`
- `package.json`

